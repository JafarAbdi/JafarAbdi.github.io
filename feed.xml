<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://jafarabdi.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jafarabdi.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-23T14:11:20+00:00</updated><id>https://jafarabdi.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Using Pixi as a Development Environment for ROS 2</title><link href="https://jafarabdi.github.io/blog/2025/ros2-pixi-dev/" rel="alternate" type="text/html" title="Using Pixi as a Development Environment for ROS 2"/><published>2025-08-23T00:00:00+00:00</published><updated>2025-08-23T00:00:00+00:00</updated><id>https://jafarabdi.github.io/blog/2025/ros2-pixi-dev</id><content type="html" xml:base="https://jafarabdi.github.io/blog/2025/ros2-pixi-dev/"><![CDATA[<p>When starting a new ROS 2 project with multiple team members, establishing a reproducible development environment is crucial for success. Without it, you’ll inevitably face the classic “works on my machine” problem, where code that runs perfectly for one developer fails mysteriously for another.</p> <h2 id="what-is-robostack">What is RoboStack?</h2> <p><a href="https://robostack.github.io/index.html">RoboStack</a> brings the Robot Operating System (ROS) to any platform - Linux, macOS, and Windows - using the Conda package manager. Unlike traditional ROS installations that are Linux-specific and require system-level packages, RoboStack packages ROS distributions (like Humble and Jazzy) as Conda packages that can be installed without root access.</p> <p>This approach enables easy integration of ROS with machine learning libraries like PyTorch and Flax in the same environment, making it perfect for robotics research that combines traditional robotics with modern AI workflows.</p> <h2 id="enter-pixi-a-unified-development-solution">Enter Pixi: A Unified Development Solution</h2> <p>One approach I used in the past was to create a Docker image that encapsulated all the dependencies and configurations needed for the project. This worked well for ensuring consistency across machines, but it also introduced significant complexity and frustration (see <a href="#appendix-docker-challenges-in-ros-2-development">Appendix: Docker Challenges</a> for details).</p> <p>In this post, I’ll introduce pixi as a modern alternative for creating reproducible ROS 2 development environments.</p> <h3 id="what-pixi-brings-to-the-table">What Pixi Brings to the Table</h3> <ul> <li><strong>Three tools in one</strong>: <ol> <li>Task runner (Replaces Makefile)</li> <li>Dependency management (combines conda and PyPI through uv) with a lock file</li> <li>Multi-environments management.</li> </ol> </li> <li><strong>ROS 2 integration</strong> through <a href="https://robostack.github.io/">RoboStack</a> project.</li> <li><strong>Simple multi-distro support</strong>: Easy switching between ROS 2 distributions.</li> <li><strong>Python integration</strong>: Ensuring ROS 2 and Python dependencies are compatible.</li> </ul> <p>For comprehensive documentation, visit <a href="https://pixi.sh/latest/">pixi.sh</a>.</p> <h3 id="getting-started-initial-setup">Getting Started: Initial Setup</h3> <p>Begin by initializing Pixi in your project directory:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi init
</code></pre></div></div> <p>Next, configure the appropriate channels. The channel selection depends on your target ROS 2 distribution. You can either manually edit your <code class="language-plaintext highlighter-rouge">pixi.toml</code> file or use the CLI:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Add RoboStack channel for your desired ROS 2 distribution</span>
pixi workspace channel add https://prefix.dev/robostack-jazzy
</code></pre></div></div> <p>This will update your <code class="language-plaintext highlighter-rouge">pixi.toml</code> file with:</p> <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">channels</span> <span class="p">=</span> <span class="p">[</span><span class="s">"conda-forge"</span><span class="p">,</span> <span class="s">"https://prefix.dev/robostack-jazzy"</span><span class="p">]</span>
</code></pre></div></div> <p><em>Replace <code class="language-plaintext highlighter-rouge">robostack-jazzy</code> with your desired ROS 2 distribution (e.g., <code class="language-plaintext highlighter-rouge">robostack-humble</code> for Humble).</em></p> <h3 id="ros-2-base-dependencies">ROS 2 Base Dependencies</h3> <p>Add ROS 2 dependencies using the CLI:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Add one of the following based on your project needs:</span>
pixi add ros-jazzy-ros-core        <span class="c"># Minimal core functionality</span>
pixi add ros-jazzy-ros-base        <span class="c"># Standard base installation (recommended)</span>
pixi add ros-jazzy-desktop         <span class="c"># Desktop environment with GUI tools</span>
pixi add ros-jazzy-desktop-full    <span class="c"># Complete desktop installation</span>
</code></pre></div></div> <p><strong>Pro Tip</strong>: Use the <a href="https://prefix.dev/">prefix.dev</a> package explorer to browse available packages and their dependencies. For CLI users, run: <code class="language-plaintext highlighter-rouge">pixi search --channel https://prefix.dev/robostack-jazzy ros-jazzy-desktop</code></p> <p>For common development tools, add them with:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi add colcon-common-extensions colcon-mixin cmake ninja mold sccache
</code></pre></div></div> <h3 id="dependency-management-strategy">Dependency Management Strategy</h3> <p>I’m not aware of a tool that automatically extracts dependencies from <code class="language-plaintext highlighter-rouge">package.xml</code> files and updates the <code class="language-plaintext highlighter-rouge">pixi.toml</code> file. Hence, you will need to either manually add the required packages to your <code class="language-plaintext highlighter-rouge">pixi.toml</code> through the <code class="language-plaintext highlighter-rouge">pixi add &lt;package-name&gt;</code> command or by creating a script that parses <code class="language-plaintext highlighter-rouge">package.xml</code> files and updates the <code class="language-plaintext highlighter-rouge">pixi.toml</code> file accordingly with <code class="language-plaintext highlighter-rouge">pixi add $(my-cool-vibe-coded-script)</code>.</p> <h3 id="task-automation">Task Automation</h3> <p>Define your tasks using the CLI:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi task add build <span class="s2">"colcon build"</span>
pixi task add <span class="nb">test</span> <span class="s2">"colcon test"</span> <span class="nt">--depends-on</span> build
</code></pre></div></div> <p>Execute tasks with simple commands:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi run <span class="nb">test</span>  <span class="c"># Automatically runs build first, then test</span>
</code></pre></div></div> <p><strong>Advanced Task Features Worth Exploring:</strong></p> <ul> <li><a href="https://pixi.sh/latest/workspace/advanced_tasks/#task-arguments">Task arguments</a> for parameterized execution</li> <li><a href="https://pixi.sh/latest/workspace/advanced_tasks/#caching">Task caching</a> for improved performance</li> </ul> <h3 id="multi-environment-support">Multi-Environment Support</h3> <p>One of Pixi’s most powerful features is seamless multi-environments support. You can set this up using CLI commands:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Setup Humble environment</span>
pixi workspace channel add https://prefix.dev/robostack-humble <span class="nt">--feature</span> humble
pixi workspace environment add humble <span class="nt">--feature</span> humble
pixi add ros-humble-ros-base <span class="nt">--feature</span> humble

<span class="c"># Setup Jazzy environment</span>
pixi workspace channel add https://prefix.dev/robostack-jazzy <span class="nt">--feature</span> jazzy
pixi workspace environment add jazzy <span class="nt">--feature</span> jazzy
pixi add ros-jazzy-ros-base <span class="nt">--feature</span> jazzy
</code></pre></div></div> <p>This creates the following configuration in your <code class="language-plaintext highlighter-rouge">pixi.toml</code>:</p> <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[feature.jazzy.dependencies]</span>
<span class="py">ros-jazzy-ros-base</span> <span class="p">=</span> <span class="s">"*"</span>

<span class="nn">[feature.humble.dependencies]</span>
<span class="py">ros-humble-ros-base</span> <span class="p">=</span> <span class="s">"*"</span>

<span class="nn">[environments]</span>
<span class="py">humble</span> <span class="o">=</span> <span class="p">{</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"humble"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">jazzy</span> <span class="o">=</span> <span class="p">{</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"jazzy"</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div> <p>Switch between environments effortlessly:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi shell <span class="nt">-e</span> jazzy   <span class="c"># Enter Jazzy environment</span>
pixi shell <span class="nt">-e</span> humble  <span class="c"># Switch to Humble environment</span>
</code></pre></div></div> <p>You can also create specialized environments for different purposes:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Setup linting environment</span>
pixi add pre-commit <span class="nt">--feature</span> lint
pixi workspace environment add lint <span class="nt">--feature</span> lint <span class="nt">--no-default-feature</span>
pixi task add lint <span class="s2">"pre-commit run --all-files"</span> <span class="nt">--feature</span> lint
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi run lint
</code></pre></div></div> <p>This eliminates the need for multiple Docker containers.</p> <h3 id="pypi-dependencies">PyPi dependencies</h3> <p>Pixi uses <a href="https://docs.astral.sh/uv/">uv</a> for managing PyPI dependencies alongside Conda packages. To add PyPI packages, use:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi add <span class="nt">--pypi</span> numpy scipy matplotlib
</code></pre></div></div> <p>It also supports extras. For example, to add Flask with async support:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixi add <span class="nt">--pypi</span> flask[async]
</code></pre></div></div> <p>This will update your <code class="language-plaintext highlighter-rouge">pixi.toml</code> file with:</p> <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[pypi-dependencies]</span>
<span class="py">flask</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="py">"&gt;</span><span class="p">=</span><span class="mf">3.1</span><span class="err">.</span><span class="mi">2</span><span class="p">,</span> <span class="err">&lt;</span><span class="mi">4</span><span class="s">", extras = ["</span><span class="err">async</span><span class="s">"] }</span><span class="err">
</span></code></pre></div></div> <p>If you want to add a source python package, you can do so by specifying the path:</p> <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[pypi-dependencies]</span>
<span class="py">my_cool_library</span> <span class="o">=</span> <span class="p">{</span> <span class="py">path</span> <span class="p">=</span> <span class="s">"./my_cool_library"</span><span class="p">,</span> <span class="py">editable</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="py">extras</span> <span class="p">=</span> <span class="p">[</span><span class="s">"dev"</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div> <h3 id="cross-platform-support">Cross-Platform Support</h3> <p>Most of the RoboStack packages are available in <code class="language-plaintext highlighter-rouge">linux-64</code>, <code class="language-plaintext highlighter-rouge">linux-aarch64</code>, <code class="language-plaintext highlighter-rouge">osx-64</code>, <code class="language-plaintext highlighter-rouge">osx-arm64</code>, and <code class="language-plaintext highlighter-rouge">win-64</code>. If you are lucky enough and all your other dependencies are available on these platforms, you can use Pixi to create a cross-platform ROS 2 development environment.</p> <h3 id="streamlined-cicd-workflows">Streamlined CI/CD Workflows</h3> <p>This part is what I’m mostly excited about when using Pixi. Pixi ensures that:</p> <ul> <li>Local development environments match CI exactly</li> <li>Failed tests can be debugged locally with identical conditions</li> <li>No more “works on my machine” scenarios</li> </ul> <p>While tools like <a href="https://github.com/ros-industrial/industrial_ci">industrial_ci</a> remain valuable, Pixi’s reproducibility makes debugging significantly more straightforward.</p> <h3 id="example-implementation">Example Implementation</h3> <p>For a practical demonstration, explore this complete ROS 2 project using Pixi: <a href="https://github.com/JafarAbdi/pixi_ros2_example">pixi_ros2_example</a>.</p> <p>The project showcases:</p> <ul> <li>Dual support for Humble and Jazzy distributions</li> <li>Clean, self-contained structure</li> <li>Automated CI/CD integration</li> </ul> <p><strong>Project Structure:</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>project_root/
├── .github/workflows/ci.yaml    <span class="c"># CI/CD configuration</span>
├── pixi.toml                    <span class="c"># Project configuration</span>
├── pixi.lock                    <span class="c"># Dependency lock file</span>
├── colcon_defaults.yaml         <span class="c"># Colcon settings</span>
├── build/                       <span class="c"># Build artifacts</span>
├── <span class="nb">install</span>/                     <span class="c"># Installation directory</span>
├── pkg1/                        <span class="c"># ROS 2 package 1</span>
├── pkg2/                        <span class="c"># ROS 2 package 2</span>
└── ...
</code></pre></div></div> <h3 id="bonus-git-worktree-integration">Bonus: Git Worktree Integration</h3> <p>I’m a big fan of <a href="https://git-scm.com/docs/git-worktree">git-worktree</a>. With this approach, I can easily manage multiple branches of the same repository without needing to clone it multiple times or stash changes when switching branches. This is particularly useful for ROS 2 development, where you might want to work on multiple features or bug fixes simultaneously.</p> <p>Simply running <code class="language-plaintext highlighter-rouge">git worktree add ../worktree_dirname branch_name</code> creates a new directory with the specified branch checked out, allowing you to work on it independently.</p> <h3 id="current-limitations-and-considerations">Current Limitations and Considerations</h3> <ul> <li><strong>Synchronizing dependencies from package.xml</strong>: You will need to manually add dependencies from <code class="language-plaintext highlighter-rouge">package.xml</code> to the <code class="language-plaintext highlighter-rouge">pixi.toml</code> file. This is a bit of a hassle, but manageable.</li> <li><strong>ros-testing packages</strong>: Currently, RoboStack does not provide packages from the <a href="https://docs.ros.org/en/humble/Installation/Testing.html#deb-testing-repository"><code class="language-plaintext highlighter-rouge">ros-testing</code> repository</a>.</li> <li><strong>Stability concerns</strong>: Pixi is still not stable, and some features are experimental. For example, in previous versions of pixi, having an environment variable in the <code class="language-plaintext highlighter-rouge">activation</code> section of <code class="language-plaintext highlighter-rouge">pixi.toml</code> would cause the value to be expanded, but it stopped working in v0.51.0 and was reverted in v0.52.0. This can lead to unexpected behaviors. Fortunately, you can pin the pixi version in your <code class="language-plaintext highlighter-rouge">pixi.toml</code> file to avoid such issues using <a href="https://pixi.sh/latest/reference/pixi_manifest/#requires-pixi-optional">requires-pixi</a>.</li> </ul> <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[activation.env]</span>
<span class="c"># In v0.51.0 the expansion is not performed, so the value is literally "$CONDA_PREFIX/my_env_var"</span>
<span class="py">MY_ENV_VAR</span><span class="p">=</span><span class="s">"$CONDA_PREFIX/my_env_var"</span>
</code></pre></div></div> <ul> <li><strong>Specialized hardware support</strong>: For Jetson machines, NVidia provides custom builds for PyTorch/TorchVision that require specific handling. Using standard PyPI/Conda packages would cause segfaults or crashes. The best solution I’m aware of for this specific case is still using Docker.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>As someone who has been working in robot learning where projects require a mix of Python and C++ codebases alongside complex dependency management spanning both ROS 2 and ML frameworks, Pixi has been a game-changer. The ability to seamlessly manage conda-forge packages for ROS 2 components alongside PyPI packages for machine learning dependencies in a single, reproducible environment has dramatically reduced development friction and allowed me to iterate much faster.</p> <h2 id="appendix-advanced-pixi-usage">Appendix: Advanced Pixi Usage</h2> <p>Beyond ROS 2, I’ve successfully used Pixi to build complex projects like OMPL, MuJoCo, MuJoCo MPC, and llama.cpp from source - you can find these configurations in my <a href="https://github.com/JafarAbdi/pixi_workspaces">pixi_workspaces</a> repository.</p> <h2 id="appendix-docker-challenges-in-ros-2-development">Appendix: Docker Challenges in ROS 2 Development</h2> <p>Having worked with Docker for ROS 2 development, the typical workflow involves three files: a Dockerfile with several stages (base image with ROS 2 installed, dependency installation, build stage to compile ROS packages, and final dev stage with necessary tools), a docker-compose file defining services like the dev environment and CI/CD testing that mount the workspace and set environment variables, and finally a Makefile that orchestrates the build and run commands.</p> <p>However, this approach has several significant drawbacks:</p> <ul> <li> <p>Reproducibility issues: To truly ensure reproducibility, you need to pin every dependency version in the Dockerfile — system &amp; ROS 2 packages (via apt), Python packages (via pip). While ROS 2 provides a snapshot repository after each release and distro (<a href="http://wiki.ros.org/SnapshotRepository">snapshot repository</a>), you still need to create custom scripts to scrape package.xml files and requirements.txt files to generate lock files containing all dependencies and their versions. As far as I know, no tool does this automatically for ROS 2 packages. You also need to ensure PyPI dependencies are compatible and won’t cause runtime errors due to version mismatches.</p> </li> <li> <p>Slow build times: If you are not careful with your docker build’s context, you can end up with invalidating the Docker cache for every build, leading to long build times and slow development cycles.</p> </li> </ul> <div class="row" style="text-align: center;"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://imgs.xkcd.com/comics/compiling-480.webp 480w,https://imgs.xkcd.com/comics/compiling-800.webp 800w,https://imgs.xkcd.com/comics/compiling-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://imgs.xkcd.com/comics/compiling.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" style=" max-width: 200px; " data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Typical xkcd developer waiting for Docker to build a ROS 2 workspace. </div> <ul> <li> <p>Image size bloat: Docker images become massive, especially when adding CUDA and other heavy dependencies</p> </li> <li> <p>Disk space consumption: Docker images can take up a lot of disk space, just run <code class="language-plaintext highlighter-rouge">docker system df</code> to see how much space is consumed.</p> </li> </ul> <div class="row" style="text-align: center;"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/heaviest_objects_in_the_universe-480.webp 480w,/assets/img/heaviest_objects_in_the_universe-800.webp 800w,/assets/img/heaviest_objects_in_the_universe-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/heaviest_objects_in_the_universe.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" style=" max-width: 200px; " data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Heaviest objects in the universe: neutron stars, black holes, and Docker images. <a href="https://bsky.app/profile/xeiaso.net/post/3lglgdrjzfs22" target="_blank">(Source: Bluesky post)</a> </div> <ul> <li>Development Workflow Friction: This might be specific to robot learning + ROS 2 workflows. It’s often much simpler to create a virtual environment with uv or poetry for ML code, install dependencies directly, and run your models. However, this approach creates two separate environments: one for ROS 2 packages and another for machine learning code. This split leads to integration challenges when you finally want to deploy your trained model on the robot. (Note that Conda isn’t a viable solution here either, as both apt-provided ROS 2 and Conda modify environment variables in conflicting ways.)</li> </ul> <hr/> <h3 id="acknowledgments">Acknowledgments</h3> <p>Thanks to Sam Pfeiffer and Sebastian Castro for reviewing this post and providing helpful feedback.</p>]]></content><author><name></name></author><category term="ROS2"/><category term="pixi"/><category term="docker"/><summary type="html"><![CDATA[When starting a new ROS 2 project with multiple team members, establishing a reproducible development environment is crucial for success. Without it, you’ll inevitably face the classic “works on my machine” problem, where code that runs perfectly for one developer fails mysteriously for another.]]></summary></entry></feed>